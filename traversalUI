

/**
 * @author Joe Azar
 * @version 1.3.1
 * 
 * v1.0 - Standard Build, all basic features
 * v1.1 - Added linear drawing, optimized point selection code and drawing methods, updated GUI and overall look.
 * v1.2 - Two new sizes, Pixel and Super-Sampled. Optimized sampling drawing algorithm. 
 * v1.3 - Added caching [about an 11% increase in generations/second].
 * v1.3.1 - Patched bug where cached values [yes, I know how that sounds] would cause erratic life behavior. Also added ability to show cachedVals. Sped up drawing algorithm.
 * v1.3.2 - Fully integrated Breesenham's line algorithm with Pixel and Super-Sampled grids. Much faster and more reliable.
 * 
 * TODO: Boundless grid.
 */
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;

import javax.swing.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import GraphingIV.cubeLink;

public class traversalUI extends JFrame
{
	traversalLink tr = new traversalLink();
	int gX = java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment().getMaximumWindowBounds().width;
	int gY = java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment().getMaximumWindowBounds().height;
	static JTextField timing;
	static JSlider cVal1;
	static JSlider cVal2;
	static JSlider cVal3;
	static JLabel gen1;
	static JLabel pop1;
	static JLabel cVal1L;
	static JLabel cVal2L;
	static JLabel cVal3L;
	static JLabel timingL;
	static JLabel brushL;
	static JToggleButton start;
	static JButton step;
	static JButton reset;
	static JToggleButton showCached;
	static JSlider brush;
	static JComboBox grid;
	int preX;
	int preY;
	boolean first = true;
	boolean zoom = false;
	String[] txts1 = { "Big", "Medium", "Small", "Tiny", "Eensy-Weensy", "Pixel", "Super-Sampled" };

	public traversalUI()
	{
		setResizable(true);
		setTitle("Conway's GOL");
		setSize(gX, gY);
		setDefaultCloseOperation(EXIT_ON_CLOSE);
		// --------------------------------------------------------------------
		timing = new JTextField();
		timing.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				try
				{
					String text = timing.getText();
					timing.setText("");
					text.trim();
					int i = Integer.parseInt(text);
					tr.t.time = i;
					timingL.setText("Delay (ms) [" + tr.t.time + "]: ");
					repaint();
				}
				catch (Exception e)
				{
					System.out.println("Bad Input!");
				}
			}
		});
		cVal1 = new JSlider(SwingConstants.HORIZONTAL, 1, 8, 2);
		cVal1.setMajorTickSpacing(1);
		cVal1.setPaintTicks(true);
		cVal1.addChangeListener(new ChangeListener()
		{
			public void stateChanged(ChangeEvent e)
			{
				tr.t.val1 = cVal1.getValue();
				repaint();
			}
		});
		cVal2 = new JSlider(SwingConstants.HORIZONTAL, 1, 8, 3);
		cVal2.setMajorTickSpacing(1);
		cVal2.setPaintTicks(true);
		cVal2.addChangeListener(new ChangeListener()
		{
			public void stateChanged(ChangeEvent e)
			{
				tr.t.val2 = cVal2.getValue();
				repaint();
			}
		});
		cVal3 = new JSlider(SwingConstants.HORIZONTAL, 1, 8, 3);
		cVal3.setMajorTickSpacing(1);
		cVal3.setPaintTicks(true);
		cVal3.addChangeListener(new ChangeListener()
		{
			public void stateChanged(ChangeEvent e)
			{
				tr.t.val3 = cVal3.getValue();
				repaint();
			}
		});
		step = new JButton("Step");
		step.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				tr.t.step = true;
				repaint();
			}
		});
		reset = new JButton("Reset Grid");
		reset.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				tr.t.start = false;
				start.setSelected(false);
				start.setText("Start");
				try
				{
					Thread.sleep(100);
				}
				catch (InterruptedException ex)
				{
					Thread.currentThread().interrupt();
				}
				tr.t.reset();
				repaint();
			}
		});
		showCached = new JToggleButton("Show Cached");
		showCached.addItemListener(new ItemListener()
		{
			public void itemStateChanged(ItemEvent ev)
			{
				if (ev.getStateChange() == ItemEvent.SELECTED)
				{
					// tr.t.showGrid = true;
					tr.t.useCached = true;
					showCached.setText("Hide Cached");
				}
				else if (ev.getStateChange() == ItemEvent.DESELECTED)
				{
					// tr.t.showGrid = false;
					tr.t.useCached = false;
					showCached.setText("Show Cached");
					repaint();
				}
			}
		});
		start = new JToggleButton("Start");
		start.addItemListener(new ItemListener()
		{
			public void itemStateChanged(ItemEvent ev)
			{
				if (ev.getStateChange() == ItemEvent.SELECTED)
				{
					tr.t.start = true;
					start.setText("Stop");
				}
				else if (ev.getStateChange() == ItemEvent.DESELECTED)
				{
					tr.t.start = false;
					start.setText("Start");
					repaint();
				}
			}
		});
		brush = new JSlider(SwingConstants.HORIZONTAL, 1, 20, 2);
		brush.setMajorTickSpacing(1);
		brush.setPaintTicks(true);
		brush.addChangeListener(new ChangeListener()
		{
			public void stateChanged(ChangeEvent e)
			{
				tr.t.brush = brush.getValue();
				repaint();
			}
		});
		grid = new JComboBox(txts1);
		grid.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				tr.t.start = false;
				start.setSelected(false);
				start.setText("Start");
				JComboBox cb = (JComboBox) evt.getSource();
				// a quick but effective fix
				try
				{
					Thread.sleep(150);
				}
				catch (InterruptedException ex)
				{
					Thread.currentThread().interrupt();
				}
				tr.t.resizeGrid(cb.getSelectedIndex());
				brush.setValue(tr.t.brush); // doesn't seem to work... ?
			}
		});
		timingL = new JLabel("Delay (ms) [" + tr.t.time + "]: ");
		brushL = new JLabel("Brush size: ");
		cVal1L = new JLabel("Underpop Lim [Default 2]: ");
		cVal2L = new JLabel(" Overpop Lim [Default 3]: ");
		cVal3L = new JLabel(" \"Birth\" Lim [Default 3]: ");
		gen1 = new JLabel("Generation: " + tr.t.gen);
		pop1 = new JLabel("Living Cells: " + tr.t.pop);
		// ------------------------------------------------------------------------
		tr.addMouseListener(new MouseListener()
		{
			@Override
			public void mouseEntered(MouseEvent arg0)
			{
			}

			@Override
			public void mouseExited(MouseEvent arg0)
			{
			}

			@Override
			public void mousePressed(MouseEvent arg0)
			{
				tr.t.findIndexSmoothed(arg0.getX(), arg0.getY());
				preX = arg0.getX();
				preY = arg0.getY();
				repaint();
			}

			@Override
			public void mouseReleased(MouseEvent arg0)
			{
				tr.t.updatePop();
			}

			@Override
			public void mouseClicked(MouseEvent e)
			{
			}
		});
		tr.addMouseMotionListener(new MouseMotionListener()
		{
			@Override
			public void mouseDragged(MouseEvent arg0)
			{
				if (first)
				{
					preX = arg0.getX();
					preY = arg0.getY();
					tr.t.findIndexSmoothed(preX, preY, arg0.getX(), arg0.getY());
					first = false;
				}
				else if (tr.t.superSampled)
				{
					tr.t.findIndexSmoothedII(preX << 1, preY << 1, arg0.getX() << 1, arg0.getY() << 1);
				}
				else if (tr.t.useBres)
				{
					tr.t.findIndexSmoothedII(preX, preY, arg0.getX(), arg0.getY());
				}
				else
				{
					tr.t.findIndexSmoothed(preX, preY, arg0.getX(), arg0.getY());
				}
				preX = arg0.getX();
				preY = arg0.getY();
				repaint();
			}

			@Override
			public void mouseMoved(MouseEvent arg0)
			{
			}
		});
		// -----------------------------------------------------------------------
		reset.setBounds(gX - 190, 70, 150, 50);
		timingL.setBounds(gX - 190, 250, 100, 20);
		timing.setBounds(gX - 190, 280, 150, 40);
		tr.setBounds(5, 5, 1154, 928);
		start.setBounds(gX - 190, 130, 150, 50);
		step.setBounds(gX - 190, 190, 150, 50);
		brush.setBounds(gX - 190, 360, 155, 40);
		brushL.setBounds(gX - 190, 330, 150, 20);
		grid.setBounds(gX - 190, 420, 150, 30);
		showCached.setBounds(gX - 190, 470, 150, 50);
		cVal1L.setBounds(gX - 190, 530, 150, 20);
		cVal1.setBounds(gX - 190, 560, 150, 40);
		cVal2L.setBounds(gX - 190, 610, 150, 20);
		cVal2.setBounds(gX - 190, 640, 150, 40);
		cVal3L.setBounds(gX - 190, 690, 150, 20);
		cVal3.setBounds(gX - 190, 720, 150, 40);
		gen1.setBounds(gX - 190, 10, 150, 20);
		pop1.setBounds(gX - 190, 35, 150, 20);
		add(gen1);
		add(pop1);
		add(reset);
		add(cVal1);
		add(cVal1L);
		add(cVal2);
		add(cVal2L);
		add(cVal3);
		add(cVal3L);
		add(showCached);
		add(grid);
		add(brushL);
		add(brush);
		add(start);
		add(step);
		add(timingL);
		add(timing);
		add(tr); // always last
		setVisible(true);
		tr.t.popGrid();
		while (true)
		{ // this little ditty took me a *while* to figure out
			tr.t.start();
			gen1.setText("Generation: " + tr.t.gen);
			pop1.setText("Living Cells: " + tr.t.pop);
			repaint();
		}
	}
}
